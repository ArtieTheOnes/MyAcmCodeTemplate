/*
  stoer-Wagner 算法求一个无向图的全局最小割,
  算法复杂度为O(n^3)
 */
#include<cstdio>
#include<cstring>
#define MAXN 510
#define inf 1000000000
using namespace std;
int w[MAXN];
int link[MAXN][MAXN];
bool inq[MAXN];
bool die[MAXN]; //die表示i是否已经被合并了
int n,m,left;
void input()
{
  int x,y,c;
  memset(link,0,sizeof(link));
  for(int i=0;i<m;i++)
  {
    scanf("%d%d%d",&x,&y,&c);
    x--;
    y--;
    link[x][y]+=c;
    link[y][x]+=c;
  }
}
bool connect()
{
  int cnt=0;
  memset(inq,0,sizeof(inq));
  dfs(0,cnt);
  return cnt==n;
}
void contract(int s,int t)//压缩
{
  die[s]=true;
  for(int i=0;i<n;i++) if(link[s][i]){
      link[i][t]=(link[t][i]+=link[s][i]);
      link[s][i]=link[i][s]=0;
   }
}
int mincut(int &s,int &t)  
{
  memset(inq,0,sizeof(inq));
  memset(w,255,sizeof(w)); //w[x]表示sigma{link[i][x] | i 属于 A} 
  int start;
  for(start=0;start<n;start++) if(!die[start]) break;
  inq[start]=true;
  for(int i=0;i<n;i++) if(!die[i]) w[i]=link[i][start];
  for(int i=0;i<left-1;i++)
  {
    int x=-1,Max=-inf;
    for(int j=0;j<n;j++) if(!die[j] && !inq[j] && w[j]>Max) Max=w[j],x=j;
    sure(x>=0);
    inq[x]=true;
    s=t; t=x;
    for(int j=0;j<n;j++)
      if(!inq[j] && !die[j]){
        if(w[j]>=0) w[j]+=link[x][j];//修改w
        else {
          w[j]=0;
          for(int k=0;k<n;k++) if(inq[k]) w[j]+=link[k][j];
        }
      }
  }
  return w[t];//w[t]为最小割
}
void stoer()
{
  int min_cut=inf,tmp_cut;
  int s,t;
  memset(die,0,sizeof(die));
  left=n;
  for(int i=0;i<n-1;i++)
  {
    tmp_cut=mincut(s,t);
    if(tmp_cut<min_cut) min_cut=tmp_cut;
    contract(s,t);
    left--;
  }
  printf("%d\n",min_cut);
}
int main()
{
  freopen("fzu2001.in","r",stdin);
  int st;
  while(scanf("%d%d%d",&n,&m,&st),n+m+st)
  {
    input();
    stoer();    
  }
  return 0;
}
